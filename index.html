<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SnailBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SnailBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SnailBlog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SnailBlog">
  
    <link rel="alternate" href="/atom.xml" title="SnailBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SnailBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">java,mysql,网络协议</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-network_拥塞避免" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/07/network_拥塞避免/" class="article-date">
  <time datetime="2017-09-07T07:19:53.002Z" itemprop="datePublished">2017-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络协议/">网络协议</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/network_拥塞避免/">TCP的超时与重传</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。 TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。</p>
<p>拥塞避免算法和慢启动算法</p>
<p>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。其中的工作原理如下：</p>
<pre><code>1）对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节
2）TCP输出不能超过cwnd和接收方的通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口是对接收方的流量控制。
   拥塞避免是发送端感受到网络拥塞的估计，通告窗口是接收方在改连接上的可用缓存大小。
3）当拥塞发送时(超时或者受到重复确认),ssthresh被设置为当前窗口大小的一半即cwnd的一半)。如果是超时引起的拥塞，cwnd被设置成一个报文段。
4）当新的数据被对方确认，就增加cwnd，具体操作如下：
    4.1）当cwnd&lt;ssthresh,使用慢启动(每次受到确认，cwnd+1)
    4.2）当cwnd&gt;ssthresh，使用拥塞算法(每次受到确认，cwnd+=1/cwnd)
    4.3）当cwnd=ssthresh,以上两种算法都可以
</code></pre><p>快速重传与快速恢复算法</p>
<p>TCP Reno算法</p>
<pre><code>1）当收到第三个重复的ACK时，将ssthresh设置成当前拥塞窗口的一半(cwnd/2)。重传丢失报文段。设置cwnd为ssthresh加上3倍的报文段大小。
2）每次受到另外一个重复的ACK时，cwnd增加1个报文段大小并发送一个分组
3）当下一个确认新数据的ACK到达时，设置cwnd为ssthresh，进入拥塞避免阶段
</code></pre><p>这个算法存在问题，多个报文同时丢失的情况下会出现性能问题。因为会多次执行快速重传和快速恢复算法</p>
<p>TCP NEW Reno算法</p>
<pre><code>当发送方这边收到3个重复，进入快速重传模式，开始重传丢失的包，如果只有一个包丢失，那么重传这个包后回来的ack就是发送方数据的ack。
否则就说明有多个包丢失，我们叫这个ACK为partial ACK。一旦发送方发现了partial ACK出现，那么发送方就继续推理出来有多个包丢失了，
于是继续重传丢失的包，知道不在出现partial ACK，整个过程结束。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/07/network_拥塞避免/" data-id="cj7adr07c0016p8q5rp2qo9f7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络协议/">网络协议</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-B+TREE" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/30/B+TREE/" class="article-date">
  <time datetime="2017-08-30T03:29:00.753Z" itemprop="datePublished">2017-08-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/30/B+TREE/">B-TREE/B+TREE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>B-TREE即平衡多路查找路(B-&gt;balance),一颗m阶的B-TREE有如下的特征：</p>
<pre><code>1) 树中每个结点至多有m个孩子；

2) 除根结点和叶子结点外，其它每个结点至少有有ceil(m / 2)个孩子；

3) 若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；

4) 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为null)；

5) 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：

a) Ki (i=1...n)为关键字，且关键字按顺序排序K(i-1)&lt; Ki。

b) Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。

c) 关键字的个数n必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。
</code></pre><p>B-TREE的查询操作<br><img src="/images/B-TREE.png" alt="B-TREE的查询操作"></p>
<pre><code>首先把磁盘块1导入到内存中，通过折半查找,找到P3指针(50&lt;51)
通过P3指针找到磁盘块4，将磁盘块4导入内存中，通过折半查找P10指针(51&lt;62)
通过P10指针找到磁盘块9，将磁盘块9导入内存中，通过值班查找找到51
至此，整个查找过程就结束了，这个过程一共进行了三次磁盘IO
</code></pre><p>B-TREE的添加操作</p>
<pre><code>插入一个元素时，首先在B-TREE中是否存在，如果不存在，先判断叶子节点的空间是否足够，如果足够，就往叶子节点里面添加，如果不够，就需要分裂页操作。
分裂页将一半数量的关键字分裂到新的叶子节点，同时将中间节点更新到父节点中，这时候需要分两种情况，如果父节点还没满，就直接插入，如果父节点已经满，
需要分裂页，父节点中间节点更新到爷爷节点，整个过程以此类推。直到整棵树平衡。
</code></pre><p>B-TREE的删除操作</p>
<pre><code>A、删除节点在叶子节点上
A.1)如果被删除关键字所在结点的原关键字个数n&gt;=ceil(m/2)，直接删除该节点的关键字。
A.2)如果被删除关键字所在结点的关键字个数n等于ceil(m/2)-1，那么需要看看兄弟节点
    A.2.1.如果兄弟节点关键字&gt;=ceil(m/2),采用覆盖操作，父节点覆盖删除节点，兄弟节点最值覆盖原来的父节点
    A.2.2.如果兄弟节点关键字=ceil（m/2),需要把兄弟节点与父节点合并作为新节点，合并后可能导致父节点不符合B-TREE结构要求，
          需要继续合并，直到B-TREE满足条件。
B、删除的节点不在叶子节点上，可以通过将左子书的最大关键字（右字数的最小节点）K-max覆盖到要删除的节点key-parent。
   接下来问题相当于转成删除key-max节点的问题，步骤转向A
</code></pre><p>B+TREE是B-TREE的一种优化</p>
<pre><code>一颗m阶的B+TREE和B-TREE异同点：
1、有n棵子树的节点包含n-1个关键字(此处有争议，部分教材是n-1个关键字，但是部分教材是n个关键字)
2、所有关键字以及值都放在叶子节点中(非叶子节点相当于索引)
</code></pre><p>B+TREE的添加操作分成三种情况</p>
<pre><code>A)如果叶子节还没满，直接插入
B)如果叶子节点满，父节点还没满，拆分叶子节点，将中间节点放入父节点中
  小于中间节点的放在父节点的左边，大于中间节点的放在父节点的右边
C)如果叶子节点满了，父节点也满了，拆分叶子节点，小于中间节点的放在左边
  大于中间节点的放在右边，拆分父节点小于中间节点的放在左边大于中间节点的
  放右边。中间节点放在上一层。以此类推。直到整颗树平衡。
</code></pre><p>B+TREE的删除操作</p>
<pre><code>A)如果叶子节点高于填充因子，直接删除节点
B)如果叶子节点低于填充因子，且父节点高于填充因子，
  需要合并兄弟节
  更新父节点
C)如果叶子结点低于填充因子，且父节点低于填充因子，
  需要合并兄弟节点
  更新父节点
  合并父节点以及更新对应的节点
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/30/B+TREE/" data-id="cj7adr0600001p8q5dhtkcqhh" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/B-tree/">B+tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-auth2.0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/26/auth2.0/" class="article-date">
  <time datetime="2017-08-26T09:43:16.037Z" itemprop="datePublished">2017-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OAuth2-0/">OAuth2.0</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/26/auth2.0/">OAuth2.0</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>OAuth(开放授权)是一个开放标准，允许用户授权第三方应用访问用户在其他平台存储的数据(前提是平台有授权)，而不需要给第三方提供账号和密码。(简单的说就是一个验证、授权的过程)</p>
<p><strong>应用场景：</strong></p>
<p>第三方登录。例如网站A想接入Google、QQ、wechat等第三方的登录。那么需要怎么做呢？首先是A网站根据用户的选择(Google、QQ、wechat等)重定向到对应的第三方登录页面，通过用户授权。用户授权通过后网站A会获取到一个授权码(get方式)，网站A带上授权码向第三方申请令牌（post方式），第三方通过验证后给网站返回令牌信息。网站A通过令牌信息可以调用第三方对应的接口，例如登录成功后获取用户信息。(OAuth2.0的应用场景其实有很多，比如单点登录，API调用等)</p>
<p><strong>具体实现：</strong></p>
<pre><code>在OAuth2.0中，实现的方式有很多种，在这里我只写一种，即授权码模式。
授权码模式是功能最完整、流程最严密的授权模式。        
 +----------+
 | Resource |
 |   Owner  |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier      +---------------+
 |         -+----(A)-- &amp; Redirection URI ----&gt;|               |
 |  User-   |                                 | Authorization |
 |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
 |          |                                 |               |
 |         -+----(C)-- Authorization Code ---&lt;|               |
 +-|----|---+                                 +---------------+
   |    |                                         ^      v
  (A)  (C)                                        |      |
   |    |                                         |      |
   ^    v                                         |      |
 +---------+                                      |      |
 |         |&gt;---(D)-- Authorization Code ---------&apos;      |
 |  Client |          &amp; Redirection URI                  |
 |         |                                             |
 |         |&lt;---(E)----- Access Token -------------------&apos;
 +---------+       (w/ Optional Refresh Token)

                 Figure 3: Authorization Code Flow
  (A)用户访问客户端，客户端将用户导向认证服务器(Authorization Server)
  (B)授权服务器认证资源所有者，并确定资源所有者授予或拒绝客户端的访问请求。
  (C)若资源所有者授予访问权限服务器将用户代理重定向回客户端之前提供的重定向URI（在请求中或之前）。
     重定向URI包括一个授权代码(这是一个get请求的过程，授权码是一个临时令牌用于获取后期的token)
  (D)客户端拿到临时临牌后，授权服务器请求access token，这个过程用post请求，因为get请求会被记录到系统日志
  (E)授权服务器验证客户端，验证授权代码，并确保重定向URI收到的匹配用于重定向客户端的URI 步骤（C）。
     如果有效则授权服务器回应访问令牌和可选的刷新令牌
  拿到access token后，就可以访问授权服务器提供的api了。

  本文参考OAuth2.0官网，后期附上整个过程的数据包分析以及用asp.net mvc实现的代码。
  OAuth2.0官网 https://tools.ietf.org/html/rfc6749
  从认证到授权的整个过程的英文文档如下

 Note: The lines illustrating steps (A), (B), and (C) are broken into
    two parts as they pass through the user-agent.
 The flow illustrated in Figure 3 includes the following steps:
   (A)  The client initiates the flow by directing the resource owner&apos;s
        user-agent to the authorization endpoint.  The client includes
        its client identifier, requested scope, local state, and a
        redirection URI to which the authorization server will send the
        user-agent back once access is granted (or denied).


   (B)  The authorization server authenticates the resource owner (via
        the user-agent) and establishes whether the resource owner
        grants or denies the client&apos;s access request.

   (C)  Assuming the resource owner grants access, the authorization
        server redirects the user-agent back to the client using the
        redirection URI provided earlier (in the request or during
        client registration).  The redirection URI includes an
        authorization code and any local state provided by the client
        earlier.

   (D)  The client requests an access token from the authorization
        server&apos;s token endpoint by including the authorization code
        received in the previous step.  When making the request, the
        client authenticates with the authorization server.  The client
        includes the redirection URI used to obtain the authorization
        code for verification.

   (E)  The authorization server authenticates the client, validates the
        authorization code, and ensures that the redirection URI
        received matches the URI used to redirect the client in
        step (C).  If valid, the authorization server responds back with
        an access token and, optionally, a refresh token.
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/26/auth2.0/" data-id="cj7adr06p000fp8q55qc03fxz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OAuth2-0/">OAuth2.0</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-MySQL_innodb_io" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/24/MySQL_innodb_io/" class="article-date">
  <time datetime="2017-08-24T07:08:18.039Z" itemprop="datePublished">2017-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/MySQL_innodb_io/">MySQL innodb 索引原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>innodb存储引擎支持B+tree索引，哈希索引(<strong>根据表的使用情况自动为表生成哈希索引，不能人为干预</strong>)。B+tree是根据key快速找到叶子页，因为B+tree是按照顺序存储的，每个叶子也到根的距离相同，从整体的来说，是对B-tree的一个优化，降低了树的深度，减少了磁盘IO的次数。(一般磁盘每s的io次数是100次)</p>
<p><img src="/images/b+tree.png" alt="b+tree"></p>
<p>innodb是如何查找数据的呢。innod的存储结构决定了innodb需要从跟节点开始查找，节点中的指针指向下一个节点，直到最后的叶子页。叶子节点的指针指向数据。所以这些数据key就是有序的。曾看过有关.net ef框架的性能测试，测试者通过主键查找数据，来测试EF的性能。我认为这个测试的结果意义不太，因为数据库主键是一个非常特别的key，即使需要通过主键排序等其他操作，问题也不是特别大，B+tree的存储特点让主键占据了非常大的优势。不过需要主要的是，如果主键设置不合理，对于整张表的性能影响也是非常大的。</p>
<p>在innodb中，一般情况下二级索引性能比主键会差一点，但这规律不一定适合索引覆盖。首先二级索引处理我们认为添加的列之外，还会有默认的主键列，除非能够在二级索引列里面找到我们想要的数据，例如：我们在建立的覆盖索引能够获取到我们全部的数据，那么我们就可以直接从覆盖索引里面的数据然后返回客户端，不然每次都是通过二级索引得到对应的主键，然后通过主键再重复上述主键查找数据的过程。</p>
<p>根据设计，B+tree需要随机磁盘访问才能定位到叶子页，所以随机访问是不可避免的。然而，如果叶子页在物理分布上是顺序且紧密的，那么查询性能会跟好，否则对于范围查询，索引覆盖扫描等操作来说，速度可能会见底很多倍。对于索引覆盖扫描这一点更加明显。</p>
<p>innodb数据从磁盘到内存这个过程是怎么样的。这个问题曾经也困扰了我很久。其实B+tree不能通过找到key来找到特定行在磁盘的具体位置，在查找的时候只能通过key找到key所在的也，然后把页读入内存中，在内存中找到相关的记录。一般磁盘的扇区是4k，MySQL的页默认值是16k,这对频繁读写是有好处的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/24/MySQL_innodb_io/" data-id="cj7adr06j000bp8q5185kapn5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/">innodb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io/">io</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/磁盘io/">磁盘io</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_change_master" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/24/mysql_change_master/" class="article-date">
  <time datetime="2017-08-24T03:00:23.538Z" itemprop="datePublished">2017-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/mysql_change_master/">MySQL切换主库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在MySQL复制中有很多种结构，目前只介绍两种(主主，主从),事实上MySQL还有其他拓扑，例如金字塔，主库-分发主库-备库等等。这些拓扑在解决<strong>带宽瓶颈</strong>表现也非常优秀，这些拓扑结构先略过。今天先讨论一些关于主主拓扑结构和主从拓扑结构切换主库的方式。</p>
<p>一般来说，切换主库的思路就是</p>
<pre><code>先停止主库的写入
备库赶上主库
选择一台备库作为主库
将备库的写操作指向新主库，开启新主库
</code></pre><p>主从拓扑(计划内切换主库)</p>
<pre><code>停止当前主库上的所有写操作，如果可以，最好能够将所有客户端程序关闭。如果使用虚拟ip，直接关闭所有客户端连接。
通过flush tables with read lock在主库上停止所有的活跃写入，这一步也是可选的。也可以在主库上设置read_only选项。这时候应该禁止向即将被替换的主库写入数据。因为一旦它不是主库，写入就意味着数据丢失。
选择一个备库作为新的主库，并确保他已经完全跟上主库
检查新主库和就主库的数据一致性
在新主库上执行stop slave
在新主库上执行change master to master_host=&apos;&apos;,然后在执行reset slave;断开与老主库的连接，并丢弃master.info的记录信息。
执行show master status记录新主库的二进制日志位置
确保在其他备库已经刚上了(如果没有赶上，后期操作比较麻烦，需要计算新主库的偏移量)
关闭旧数据库
在MySQL5.1以上的版本中，如果需要，激活新主库上时间。
将客户端连接到新主库
在备库上改变主库的ip。change master to 
</code></pre><p>主从拓扑(计划外切换主库)</p>
<pre><code>找到备库数据最新的服务器。检查每台备库上show slave status命令的输出，选择其中master_log_file/read_master_log_pos的值最新的那个。
让所有备库执行完成所有其从崩溃前的旧主库那获得的中继日志。如果在未完成前修改备库的主库，它会抛弃剩下的日志事件，从而无法获知改备库在上面地方停止。
在新主库上执行stop slave
在新主库上执行change master to master_host=&apos;&apos;,然后在执行reset slave;断开与老主库的连接，并丢弃master.info的记录信息。
执行show master status记录新主库的二进制日志位置
比较每台备库和新主库上的master_log_file/read_master_log_pos的值。
在MySQL5.1以上的版本中，如果需要，激活新主库上时间。
将客户端连接到新主库
在备库上改变主库的ip。change master to 
</code></pre><p>主主拓扑结构</p>
<pre><code>停止主动服务器上的所有写入
通过flush tables with read lock在主库上停止所有的活跃写入，否则需要kill所有客户端的连接。
在主动服务器上执行show master status，记录二进制偏移量。
使用主动服务器上的二进制日志坐标在移动服务器上执行select master_pos_wait().改语句将阻塞住，知道复制跟上主动服务器。
在被动服务器上执行set global read_only=0,这样就变成主动服务器
修改应用程序的配置，使其写入到新的主动服务器中。
</code></pre><p>通过以上的对比，可以看出主主结构在切换主库会比主备拓扑结构切换主库方便。因此如果是需要高可用的场景，选择主主拓扑主-被结构(配合keepalive，haproxy or lvs)。如果是需要实现读写分离来提升系统的性能，那么主备拓扑结构是一个很不错的选择(前提是写不是整个架构的瓶颈，因为写容量不能通过复制在提升)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/24/mysql_change_master/" data-id="cj7adr04h0000p8q5qbor8ygj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统架构/">系统架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_主主拓扑结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/21/mysql_主主拓扑结构/" class="article-date">
  <time datetime="2017-08-21T00:40:33.105Z" itemprop="datePublished">2017-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/21/mysql_主主拓扑结构/">MySQL主主拓扑结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>主主复制有两台服务器，每一个都被配置成对方的主库和备库。主主拓扑结构有两种配置，一种是主主拓扑结构中的主-主模式。这种模式下，两台服务器都可以写入。那么最大的问题就是如何防止冲突的问题，另外在两台机器上根据不同的顺序更新，可能会导致数据不同步。例如在第一台主库上：</p>
<pre><code>update tableA set col=col+1;
</code></pre><p>在第二台主库上：</p>
<pre><code>update tableA set col=col*2;
</code></pre><p>在这种情况下，第一台实际在数据库执行的是</p>
<pre><code>update tableA set col=col+1;
update tableA set col=col*2;
</code></pre><p>第一台得到的结果是4，在第二台主机上执行的是</p>
<pre><code>update tableA set col=col*2;
update tableA set col=col+1;
</code></pre><p>那么得到的结果就是3。这种拓扑结构导致了两个库的数据不一致。如果清除自己在做什么，那么可以考虑这种结构，否则，尽量别用，因为有些疑难杂症很难处理好。</p>
<p>在主主拓扑结构中还有另外一种模式，主-被拓扑模式，这种结构能够很好的避免主主结构中主-主模式的一些问题。这种结构跟主-主结构的区别在于其中被动服务器只读，如图所示。由于主主结构主-被模式配置都是对称的(其中，把对方都设置成备库的配置在往后的故障转移和故障恢复起到非常重要的作用)，所以在这种特殊的配置中，主-被模式反复切换模式很方便(这些操作相对于主从来说，会少了很多工作量，后续会对主从、主主拓扑结构的主被模式切换主库做个对比)，这对系统的故障转移和故障恢复很容易。对于整个系统实现高可用也是非常方便且有效的(可能会配合其他负载均衡如[lvs、haproxy]+keepalive或虚拟IP等相关技术一起使用，具体方案视情况而定)。<br><img src="/images/主主拓扑.png" alt="主主拓扑.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/21/mysql_主主拓扑结构/" data-id="cj7adr06z000pp8q5yad7d4jl" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL主主拓扑结构/">MySQL主主拓扑结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统架构/">系统架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-network_vrrp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/16/network_vrrp/" class="article-date">
  <time datetime="2017-08-16T03:04:31.269Z" itemprop="datePublished">2017-08-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络协议/">网络协议</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/16/network_vrrp/">vrrp协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><strong>vrrp简述：</strong></p>
<p>vrrp协议即虚拟路由冗余协议，通过多台路由设备联合组成一台虚拟的路由设备，当主机的下一跳路由出现故障时，自动选举备份路由，把业务切换到备份路由器。</p>
<p><strong>vrrp工作过程</strong>(内容来做百度百科)</p>
<p>路由器开启VRRP功能后，会根据优先级确定自己在备份组中的角色。优先级高的路由器成为主用路由器，优先级低的成为备用路由器。主用路由器定期发送VRRP通告报文，通知备份组内的其他路由器自己工作正常；备用路由器则启动定时器等待通告报文的到来。</p>
<p>VRRP在不同的主用抢占方式下，主用角色的替换方式不同：</p>
<p>在抢占方式下，当主用路由器收到VRRP通告报文后，会将自己的优先级与通告报文中的优先级进行比较。如果大于通告报文中的优先级，则成为主用路由器；否则将保持备用状态。</p>
<p>在非抢占方式下，只要主用路由器没有出现故障，备份组中的路由器始终保持主用或备用状态，备份组中的路由器即使随后被配置了更高的优先级也不会成为主用路由器。</p>
<p>如果备用路由器的定时器超时后仍未收到主用路由器发送来的VRRP通告报文，则认为主用路由器已经无法正常工作，此时备用路由器会认为自己是主用路由器，并对外发送VRRP通告报文。备份组内的路由器根据优先级选举出主用路由器，承担报文的转发功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/16/network_vrrp/" data-id="cj7adr07l001ip8q5ca2n0u0z" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vrrp协议/">vrrp协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络协议/">网络协议</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_分解关联" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/mysql_分解关联/" class="article-date">
  <time datetime="2017-08-14T10:55:43.613Z" itemprop="datePublished">2017-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/14/mysql_分解关联/">mysql分解关联</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>分解关联查询有时候是高性能查询的一种方案。在数据库中获取一张表的结果集，然后在应用程序做关联。例如表A(ID,name,age) B(ID,AID,COL1,COL2)</p>
<p>方案一 </p>
<pre><code>select * from a join b on a.id=b.aid where a.name=&apos;zhangsan&apos;;
</code></pre><p>方案二 把这个sql可拆分成</p>
<pre><code>select * from a where a.name=&apos;zhangsan&apos;; 
-- 得到3条数据，分别是id=1,2,3    
select * from b where b.aid in(1,2,3); 
-- 得到b表中的所有符合条件的数据
-- 最后应用层对查询出来的记录进行关联。
</code></pre><p>可能有人会觉得困惑，为什么不直接关联查询呢，简单粗暴，还不用多次连接数据库。事实上这种做法并没有错，但是关联查询使用内嵌循环的方式，如果数据量不是特别大的时候性能可能会比分解关联好，但是如果<strong>数据量非常大</strong>查询起来可能会非常慢，而且MySQL innodb不支持hash索引。如果把关联查询分解成单表查询，其实好处也是挺多的。</p>
<pre><code>缓存的利用，单表的查询容易被应用程序缓存。
减少锁的竞争
在应用层做关联可以更容易对业务拆分，项目更容易拓展
MySQL innodb不支持hash索引，这相当于在应用层做hash关联
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/14/mysql_分解关联/" data-id="cj7adr06s000ip8q5proyrw0w" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql分解关联/">mysql分解关联</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_轻量级连接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/mysql_轻量级连接/" class="article-date">
  <time datetime="2017-08-14T01:18:31.327Z" itemprop="datePublished">2017-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/14/mysql_轻量级连接/">mysql重构查询方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>前几天有个同事需要开发一个功能，需要的数据来自不同的数据库。同事说，在不同数据库读取数据性能很差。我倒是不太认同这样的一个说法。<br>我认为在前期对业务进行做垂直分层对后期的拓展、负载、性能、故障转移等很多方面是很有好处且很有必要的(前期对项目规模的预测很重要，如果是很小的项目就没必要这样做)，另外关于跨数据库查询性能差这种说法我认为不一定，这个要视情况而定，因为MySQL在设计上从连接到断开都是很轻量级的，在返回一个小的查询结果集方面非常高效，而且在现在的网络中，带宽和网络延迟都比以前快很多。跨数据库查询就类似(查询形式上的类似，并非性能上的类型)于在单个数据库中把一个复杂的查询拆分成几个小查询。</p>
<p>一般情况下，如果能一次查询所有的结果集，并且响应的时间在可接受的范围内那么不建议多次查询，但是有时候连表查询可能性能很差，这时候可以考虑把一个复杂的查询拆分成多个小的查询，通过多次测试找到合适的方案(事实上，跨数据库设计已对服务器做负载，就单查询方面来说，查询的性能可能会比单个数据库更高，而且在流量的高峰期会更加明显)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/14/mysql_轻量级连接/" data-id="cj7adr07o001lp8q5bhdiupjj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql重构查询方式/">mysql重构查询方式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_容量规划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/10/mysql_容量规划/" class="article-date">
  <time datetime="2017-08-10T10:56:34.134Z" itemprop="datePublished">2017-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/mysql_容量规划/">MySQL 容量规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在读密集型的应用中，主从的拓扑结构是一个比较好的解决方案。但是主从并不意味着一味地添加从服务器来扩充系统容量，因为当写操作成为系统的瓶颈时，添加的服务器越多，对主服务器的压力就会越大，并且有可能性能会降低。</p>
<p>例如：假设服务器的工作负载为10%的写和90%的读</p>
<pre><code>前提:
并且读写都是相同的工作量，每台服务器(相同配置)
每秒只能进行1000查询操作
可以把所有的读操作都分配给从服务器
</code></pre><p>基于以上情况，如果当前的服务器能够支持1000次/s的查询，那么系统需要添加多少台服务器才能提升1倍性能呢。也就是200写和1800次读。因为写就站了20%，那么每台服务器的读也就是剩下800次，在这1800次读操作中，需要至少3台服务器。如果性能在提升一倍呢。也就是400次写和3600次读，因为每台服务器的读剩下600次，那么至少需要6台。往后需要性能提升的时候在财务允许的情况下且不改变架构的情况下可以不断添加从服务器。直到性能提升到最开始的10倍也就是1000次写操作和9000次读操作。这时候无法进行读操作，因为所有的资源已经被写操作占用了。这时候写操作就是整个架构的瓶颈,如果添加从服务器只会降低服务器性能，对于整个项目来说无疑是雪上加霜。这时候只能改变系统架构，例如对系统进行垂直拆分等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/10/mysql_容量规划/" data-id="cj7adr071000sp8q5sksnv9ki" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统架构/">系统架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/githubhsb" target="_blank" title="Github"></a>
      
      
      
      
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OAuth2-0/">OAuth2.0</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongo/">mongo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/B-tree/" style="font-size: 14px;">B+tree</a> <a href="/tags/MySQL/" style="font-size: 25px;">MySQL</a> <a href="/tags/MySQL主主拓扑结构/" style="font-size: 14px;">MySQL主主拓扑结构</a> <a href="/tags/OAuth2-0/" style="font-size: 14px;">OAuth2.0</a> <a href="/tags/TCP-IP/" style="font-size: 20.6px;">TCP/IP</a> <a href="/tags/innodb/" style="font-size: 14px;">innodb</a> <a href="/tags/io/" style="font-size: 14px;">io</a> <a href="/tags/mongo/" style="font-size: 14px;">mongo</a> <a href="/tags/mysql分解关联/" style="font-size: 14px;">mysql分解关联</a> <a href="/tags/mysql重构查询方式/" style="font-size: 14px;">mysql重构查询方式</a> <a href="/tags/vrrp协议/" style="font-size: 14px;">vrrp协议</a> <a href="/tags/主从拓扑结构/" style="font-size: 14px;">主从拓扑结构</a> <a href="/tags/性能优化/" style="font-size: 16.2px;">性能优化</a> <a href="/tags/拓扑结构/" style="font-size: 14px;">拓扑结构</a> <a href="/tags/数据结构与算法/" style="font-size: 14px;">数据结构与算法</a> <a href="/tags/磁盘io/" style="font-size: 14px;">磁盘io</a> <a href="/tags/系统架构/" style="font-size: 18.4px;">系统架构</a> <a href="/tags/网络协议/" style="font-size: 22.8px;">网络协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/07/network_拥塞避免/">TCP的超时与重传</a>
          </li>
        
          <li>
            <a href="/2017/08/30/B+TREE/">B-TREE/B+TREE</a>
          </li>
        
          <li>
            <a href="/2017/08/26/auth2.0/">OAuth2.0</a>
          </li>
        
          <li>
            <a href="/2017/08/24/MySQL_innodb_io/">MySQL innodb 索引原理</a>
          </li>
        
          <li>
            <a href="/2017/08/24/mysql_change_master/">MySQL切换主库</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 Snail&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;2331104980@qq.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>