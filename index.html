<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SnailBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SnailBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SnailBlog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SnailBlog">
  
    <link rel="alternate" href="/atom.xml" title="SnailBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SnailBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">java,mysql,网络协议</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-auth2.0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/26/auth2.0/" class="article-date">
  <time datetime="2017-08-26T09:43:16.037Z" itemprop="datePublished">2017-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OAuth2-0/">OAuth2.0</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/26/auth2.0/">OAuth2.0</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>OAuth(开放授权)是一个开放标准，允许用户授权第三方应用访问用户在其他平台存储的数据(前提是平台有授权)，而不需要给第三方提供账号和密码。(简单的说就是一个验证、授权的过程)</p>
<p><strong>应用场景：</strong></p>
<p>第三方登录。例如网站A想接入Google、QQ、wechat等第三方的登录。那么需要怎么做呢？首先是A网站根据用户的选择(Google、QQ、wechat等)重定向到对应的第三方登录页面，通过用户授权。用户授权通过后网站A会获取到一个授权码(get方式)，网站A带上授权码向第三方申请令牌（post方式），第三方通过验证后给网站返回令牌信息。网站A通过令牌信息可以调用第三方对应的接口，例如登录成功后获取用户信息。(OAuth2.0的应用场景其实有很多，比如单点登录，API调用等)</p>
<p><strong>具体实现：</strong></p>
<pre><code>在OAuth2.0中，实现的方式有很多种，在这里我只写一种，即授权码模式。
授权码模式是功能最完整、流程最严密的授权模式。        
 +----------+
 | Resource |
 |   Owner  |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier      +---------------+
 |         -+----(A)-- &amp; Redirection URI ----&gt;|               |
 |  User-   |                                 | Authorization |
 |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
 |          |                                 |               |
 |         -+----(C)-- Authorization Code ---&lt;|               |
 +-|----|---+                                 +---------------+
   |    |                                         ^      v
  (A)  (C)                                        |      |
   |    |                                         |      |
   ^    v                                         |      |
 +---------+                                      |      |
 |         |&gt;---(D)-- Authorization Code ---------&apos;      |
 |  Client |          &amp; Redirection URI                  |
 |         |                                             |
 |         |&lt;---(E)----- Access Token -------------------&apos;
 +---------+       (w/ Optional Refresh Token)

                 Figure 3: Authorization Code Flow
  (A)用户访问客户端，客户端将用户导向认证服务器(Authorization Server)
  (B)授权服务器认证资源所有者，并确定资源所有者授予或拒绝客户端的访问请求。
  (C)若资源所有者授予访问权限服务器将用户代理重定向回客户端之前提供的重定向URI（在请求中或之前）。
     重定向URI包括一个授权代码(这是一个get请求的过程，授权码是一个临时令牌用于获取后期的token)
  (D)客户端拿到临时临牌后，授权服务器请求access token，这个过程用post请求，因为get请求会被记录到系统日志
  (E)授权服务器验证客户端，验证授权代码，并确保重定向URI收到的匹配用于重定向客户端的URI 步骤（C）。
     如果有效则授权服务器回应访问令牌和可选的刷新令牌
  拿到access token后，就可以访问授权服务器提供的api了。

  本文参考OAuth2.0官网，后期附上整个过程的数据包分析以及用asp.net mvc实现的代码。
  OAuth2.0官网 https://tools.ietf.org/html/rfc6749
  从认证到授权的整个过程的英文文档如下

 Note: The lines illustrating steps (A), (B), and (C) are broken into
    two parts as they pass through the user-agent.
 The flow illustrated in Figure 3 includes the following steps:
   (A)  The client initiates the flow by directing the resource owner&apos;s
        user-agent to the authorization endpoint.  The client includes
        its client identifier, requested scope, local state, and a
        redirection URI to which the authorization server will send the
        user-agent back once access is granted (or denied).


   (B)  The authorization server authenticates the resource owner (via
        the user-agent) and establishes whether the resource owner
        grants or denies the client&apos;s access request.

   (C)  Assuming the resource owner grants access, the authorization
        server redirects the user-agent back to the client using the
        redirection URI provided earlier (in the request or during
        client registration).  The redirection URI includes an
        authorization code and any local state provided by the client
        earlier.

   (D)  The client requests an access token from the authorization
        server&apos;s token endpoint by including the authorization code
        received in the previous step.  When making the request, the
        client authenticates with the authorization server.  The client
        includes the redirection URI used to obtain the authorization
        code for verification.

   (E)  The authorization server authenticates the client, validates the
        authorization code, and ensures that the redirection URI
        received matches the URI used to redirect the client in
        step (C).  If valid, the authorization server responds back with
        an access token and, optionally, a refresh token.
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/26/auth2.0/" data-id="cj6vynzp20001m4q5a34ccfqo" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OAuth2-0/">OAuth2.0</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-MySQL_innodb_io" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/24/MySQL_innodb_io/" class="article-date">
  <time datetime="2017-08-24T07:08:18.039Z" itemprop="datePublished">2017-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/MySQL_innodb_io/">MySQL innodb 索引原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>innodb存储引擎支持B+tree索引，哈希索引(<strong>根据表的使用情况自动为表生成哈希索引，不能人为干预</strong>)。B+tree是根据key快速找到叶子页，因为B+tree是按照顺序存储的，每个叶子也到根的距离相同，从整体的来说，是对B-tree的一个优化，降低了树的深度，减少了磁盘IO的次数。(一般磁盘每s的io次数是100次)</p>
<p><img src="/images/b+tree.png" alt="b+tree"></p>
<p>innodb是如何查找数据的呢。innod的存储结构决定了innodb需要从跟节点开始查找，节点中的指针指向下一个节点，直到最后的叶子页。叶子节点的指针指向数据。所以这些数据key就是有序的。曾看过有关.net ef框架的性能测试，测试者通过主键查找数据，来测试EF的性能。我认为这个测试的结果意义不太，因为数据库主键是一个非常特别的key，即使需要通过主键排序等其他操作，问题也不是特别大，B+tree的存储特点让主键占据了非常大的优势。不过需要主要的是，如果主键设置不合理，对于整张表的性能影响也是非常大的。</p>
<p>在innodb中，一般情况下二级索引性能比主键会差一点，但这规律不一定适合索引覆盖。首先二级索引处理我们认为添加的列之外，还会有默认的主键列，除非能够在二级索引列里面找到我们想要的数据，例如：我们在建立的覆盖索引能够获取到我们全部的数据，那么我们就可以直接从覆盖索引里面的数据然后返回客户端，不然每次都是通过二级索引得到对应的主键，然后通过主键再重复上述主键查找数据的过程。</p>
<p>根据设计，B+tree需要随机磁盘访问才能定位到叶子页，所以随机访问是不可避免的。然而，如果叶子页在物理分布上是顺序且紧密的，那么查询性能会跟好，否则对于范围查询，索引覆盖扫描等操作来说，速度可能会见底很多倍。对于索引覆盖扫描这一点更加明显。</p>
<p>innodb数据从磁盘到内存这个过程是怎么样的。这个问题曾经也困扰了我很久。其实B+tree不能通过找到key来找到特定行在磁盘的具体位置，在查找的时候只能通过key找到key所在的也，然后把页读入内存中，在内存中找到相关的记录。一般磁盘的扇区是4k，MySQL的页默认值是16k,这对频繁读写是有好处的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/24/MySQL_innodb_io/" data-id="cj6vynzot0000m4q5bl1eooh5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/">innodb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io/">io</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/磁盘io/">磁盘io</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_change_master" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/24/mysql_change_master/" class="article-date">
  <time datetime="2017-08-24T03:00:23.538Z" itemprop="datePublished">2017-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/系统架构/">系统架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/mysql_change_master/">MySQL切换主库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在MySQL复制中有很多种结构，目前只介绍两种(主主，主从),事实上MySQL还有其他拓扑，例如金字塔，主库-分发主库-备库等等。这些拓扑在解决<strong>带宽瓶颈</strong>表现也非常优秀，这些拓扑结构先略过。今天先讨论一些关于主主拓扑结构和主从拓扑结构切换主库的方式。</p>
<p>一般来说，切换主库的思路就是</p>
<pre><code>先停止主库的写入
备库赶上主库
选择一台备库作为主库
将备库的写操作指向新主库，开启新主库
</code></pre><p>主从拓扑(计划内切换主库)</p>
<pre><code>停止当前主库上的所有写操作，如果可以，最好能够将所有客户端程序关闭。如果使用虚拟ip，直接关闭所有客户端连接。
通过flush tables with read lock在主库上停止所有的活跃写入，这一步也是可选的。也可以在主库上设置read_only选项。这时候应该禁止向即将被替换的主库写入数据。因为一旦它不是主库，写入就意味着数据丢失。
选择一个备库作为新的主库，并确保他已经完全跟上主库
检查新主库和就主库的数据一致性
在新主库上执行stop slave
在新主库上执行change master to master_host=&apos;&apos;,然后在执行reset slave;断开与老主库的连接，并丢弃master.info的记录信息。
执行show master status记录新主库的二进制日志位置
确保在其他备库已经刚上了(如果没有赶上，后期操作比较麻烦，需要计算新主库的偏移量)
关闭旧数据库
在MySQL5.1以上的版本中，如果需要，激活新主库上时间。
将客户端连接到新主库
在备库上改变主库的ip。change master to 
</code></pre><p>主从拓扑(计划外切换主库)</p>
<pre><code>找到备库数据最新的服务器。检查每台备库上show slave status命令的输出，选择其中master_log_file/read_master_log_pos的值最新的那个。
让所有备库执行完成所有其从崩溃前的旧主库那获得的中继日志。如果在未完成前修改备库的主库，它会抛弃剩下的日志事件，从而无法获知改备库在上面地方停止。
在新主库上执行stop slave
在新主库上执行change master to master_host=&apos;&apos;,然后在执行reset slave;断开与老主库的连接，并丢弃master.info的记录信息。
执行show master status记录新主库的二进制日志位置
比较每台备库和新主库上的master_log_file/read_master_log_pos的值。
在MySQL5.1以上的版本中，如果需要，激活新主库上时间。
将客户端连接到新主库
在备库上改变主库的ip。change master to 
</code></pre><p>主主拓扑结构</p>
<pre><code>停止主动服务器上的所有写入
通过flush tables with read lock在主库上停止所有的活跃写入，否则需要kill所有客户端的连接。
在主动服务器上执行show master status，记录二进制偏移量。
使用主动服务器上的二进制日志坐标在移动服务器上执行select master_pos_wait().改语句将阻塞住，知道复制跟上主动服务器。
在被动服务器上执行set global read_only=0,这样就变成主动服务器
修改应用程序的配置，使其写入到新的主动服务器中。
</code></pre><p>通过以上的对比，可以看出主主结构在切换主库会比主备拓扑结构切换主库方便。因此如果是需要高可用的场景，选择主主拓扑主-被结构(配合keepalive，haproxy or lvs)。如果是需要实现读写分离来提升系统的性能，那么主备拓扑结构是一个很不错的选择(前提是写不是整个架构的瓶颈，因为写容量不能通过复制在提升)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/24/mysql_change_master/" data-id="cj6vynzpe0006m4q5ty76qvbu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统架构/">系统架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_主主拓扑结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/21/mysql_主主拓扑结构/" class="article-date">
  <time datetime="2017-08-21T00:40:33.105Z" itemprop="datePublished">2017-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/系统架构/">系统架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/21/mysql_主主拓扑结构/">MySQL主主拓扑结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>主主复制有两台服务器，每一个都被配置成对方的主库和备库。主主拓扑结构有两种配置，一种是主主拓扑结构中的主-主模式。这种模式下，两台服务器都可以写入。那么最大的问题就是如何防止冲突的问题，另外在两台机器上根据不同的顺序更新，可能会导致数据不同步。例如在第一台主库上：</p>
<pre><code>update tableA set col=col+1;
</code></pre><p>在第二台主库上：</p>
<pre><code>update tableA set col=col*2;
</code></pre><p>在这种情况下，第一台实际在数据库执行的是</p>
<pre><code>update tableA set col=col+1;
update tableA set col=col*2;
</code></pre><p>第一台得到的结果是4，在第二台主机上执行的是</p>
<pre><code>update tableA set col=col*2;
update tableA set col=col+1;
</code></pre><p>那么得到的结果就是3。这种拓扑结构导致了两个库的数据不一致。如果清除自己在做什么，那么可以考虑这种结构，否则，尽量别用，因为有些疑难杂症很难处理好。</p>
<p>在主主拓扑结构中还有另外一种模式，主-被拓扑模式，这种结构能够很好的避免主主结构中主-主模式的一些问题。这种结构跟主-主结构的区别在于其中被动服务器只读，如图所示。由于主主结构主-被模式配置都是对称的(其中，把对方都设置成备库的配置在往后的故障转移和故障恢复起到非常重要的作用)，所以在这种特殊的配置中，主-被模式反复切换模式很方便(这些操作相对于主从来说，会少了很多工作量，后续会对主从、主主拓扑结构的主被模式切换主库做个对比)，这对系统的故障转移和故障恢复很容易。对于整个系统实现高可用也是非常方便且有效的(可能会配合其他负载均衡如[lvs、haproxy]+keepalive或虚拟IP等相关技术一起使用，具体方案视情况而定)。<br><img src="/images/主主拓扑.png" alt="主主拓扑.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/21/mysql_主主拓扑结构/" data-id="cj6vynzpv000hm4q51yyzypbu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL主主拓扑结构/">MySQL主主拓扑结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统架构/">系统架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-network_vrrp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/16/network_vrrp/" class="article-date">
  <time datetime="2017-08-16T03:04:31.269Z" itemprop="datePublished">2017-08-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络协议/">网络协议</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/16/network_vrrp/">vrrp协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><strong>vrrp简述：</strong></p>
<p>vrrp协议即虚拟路由冗余协议，通过多台路由设备联合组成一台虚拟的路由设备，当主机的下一跳路由出现故障时，自动选举备份路由，把业务切换到备份路由器。</p>
<p><strong>vrrp实现</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/16/network_vrrp/" data-id="cj6vynzqo001cm4q5zennpplg" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vrrp协议/">vrrp协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络协议/">网络协议</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_分解关联" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/mysql_分解关联/" class="article-date">
  <time datetime="2017-08-14T10:55:43.613Z" itemprop="datePublished">2017-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/14/mysql_分解关联/">mysql分解关联</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>分解关联查询有时候是高性能查询的一种方案。在数据库中获取一张表的结果集，然后在应用程序做关联。例如表A(ID,name,age) B(ID,AID,COL1,COL2)</p>
<p>方案一 </p>
<pre><code>select * from a join b on a.id=b.aid where a.name=&apos;zhangsan&apos;;
</code></pre><p>方案二 把这个sql可拆分成</p>
<pre><code>select * from a where a.name=&apos;zhangsan&apos;; 
-- 得到3条数据，分别是id=1,2,3    
select * from b where b.aid in(1,2,3); 
-- 得到b表中的所有符合条件的数据
-- 最后应用层对查询出来的记录进行关联。
</code></pre><p>可能有人会觉得困惑，为什么不直接关联查询呢，简单粗暴，还不用多次连接数据库。事实上这种做法并没有错，但是关联查询使用内嵌循环的方式，如果数据量不是特别大的时候性能可能会比分解关联好，但是如果<strong>数据量非常大</strong>查询起来可能会非常慢，而且MySQL innodb不支持hash索引。如果把关联查询分解成单表查询，其实好处也是挺多的。</p>
<pre><code>缓存的利用，单表的查询容易被应用程序缓存。
减少锁的竞争
在应用层做关联可以更容易对业务拆分，项目更容易拓展
MySQL innodb不支持hash索引，这相当于在应用层做hash关联
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/14/mysql_分解关联/" data-id="cj6vynzq1000nm4q5pmuixmd0" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql分解关联/">mysql分解关联</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_轻量级连接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/mysql_轻量级连接/" class="article-date">
  <time datetime="2017-08-14T01:18:31.327Z" itemprop="datePublished">2017-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/14/mysql_轻量级连接/">mysql重构查询方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>前几天有个同事需要开发一个功能，需要的数据来自不同的数据库。同事说，在不同数据库读取数据性能很差。我倒是不太认同这样的一个说法。<br>我认为在前期对业务进行做垂直分层对后期的拓展、负载、性能、故障转移等很多方面是很有好处且很有必要的(前期对项目规模的预测很重要，如果是很小的项目就没必要这样做)，另外关于跨数据库查询性能差这种说法我认为不一定，这个要视情况而定，因为MySQL在设计上从连接到断开都是很轻量级的，在返回一个小的查询结果集方面非常高效，而且在现在的网络中，带宽和网络延迟都比以前快很多。跨数据库查询就类似(查询形式上的类似，并非性能上的类型)于在单个数据库中把一个复杂的查询拆分成几个小查询。</p>
<p>一般情况下，如果能一次查询所有的结果集，并且响应的时间在可接受的范围内那么不建议多次查询，但是有时候连表查询可能性能很差，这时候可以考虑把一个复杂的查询拆分成多个小的查询，通过多次测试找到合适的方案(事实上，跨数据库设计已对服务器做负载，就单查询方面来说，查询的性能可能会比单个数据库更高，而且在流量的高峰期会更加明显)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/14/mysql_轻量级连接/" data-id="cj6vynzqb000um4q56ods21tw" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql重构查询方式/">mysql重构查询方式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_容量规划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/10/mysql_容量规划/" class="article-date">
  <time datetime="2017-08-10T10:56:34.134Z" itemprop="datePublished">2017-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/系统架构/">系统架构</a>►<a class="article-category-link" href="/categories/系统架构/MySQL-容量规划/">MySQL 容量规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/mysql_容量规划/">MySQL 容量规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在读密集型的应用中，主从的拓扑结构是一个比较好的解决方案。但是主从并不意味着一味地添加从服务器来扩充系统容量，因为当写操作成为系统的瓶颈时，添加的服务器越多，对主服务器的压力就会越大，并且有可能性能会降低。</p>
<p>例如：假设服务器的工作负载为10%的写和90%的读</p>
<pre><code>前提:
并且读写都是相同的工作量，每台服务器(相同配置)
每秒只能进行1000查询操作
可以把所有的读操作都分配给从服务器
</code></pre><p>基于以上情况，如果当前的服务器能够支持1000次/s的查询，那么系统需要添加多少台服务器才能提升1倍性能呢。也就是200写和1800次读。因为写就站了20%，那么每台服务器的读也就是剩下800次，在这1800次读操作中，需要至少3台服务器。如果性能在提升一倍呢。也就是400次写和3600次读，因为每台服务器的读剩下600次，那么至少需要6台。往后需要性能提升的时候在财务允许的情况下且不改变架构的情况下可以不断添加从服务器。直到性能提升到最开始的10倍也就是1000次写操作和9000次读操作。这时候无法进行读操作，因为所有的资源已经被写操作占用了。这时候写操作就是整个架构的瓶颈,如果添加从服务器只会降低服务器性能，对于整个项目来说无疑是雪上加霜。这时候只能改变系统架构，例如对系统进行垂直拆分等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/10/mysql_容量规划/" data-id="cj6vynzq5000rm4q58lm0tz8i" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统架构/">系统架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mysql_复制拓扑结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/09/mysql_复制拓扑结构/" class="article-date">
  <time datetime="2017-08-09T05:33:46.396Z" itemprop="datePublished">2017-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/系统架构/">系统架构</a>►<a class="article-category-link" href="/categories/系统架构/MySQL主从拓扑结构/">MySQL主从拓扑结构</a>►<a class="article-category-link" href="/categories/系统架构/MySQL主从拓扑结构/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/09/mysql_复制拓扑结构/">mysql 主从拓扑结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>MySQL的主从拓扑结构在少量写大量读的情况下表现非常优越。可以把读分摊到多个备库上，直到写成为整个拓扑结构的瓶颈(<a href="https://githubhsb.github.io/2017/08/10/mysql_%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92/" target="_blank" rel="external">在容量规划会介绍为什么写会成为瓶颈</a>)。这种拓扑结构在其他拓扑结构中，是比较简单的一种，但很灵活，能满足多种要求。</p>
<pre><code>把一台备库当做待用的主库，除了复制没有其他的数据传输。
把一台备库放在远程数据中心，用作灾难恢复
延迟一个或多个备库，以备灾难恢复
使用一个备库作为开发测试等
</code></pre><p><img src="/images/主从拓扑结构.png" alt="MySQL复制-主从拓扑结构"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/09/mysql_复制拓扑结构/" data-id="cj6vynzpy000lm4q5cyvrdmve" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/主从拓扑结构/">主从拓扑结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拓扑结构/">拓扑结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统架构/">系统架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-mongo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/08/mongo/" class="article-date">
  <time datetime="2017-08-08T03:33:28.053Z" itemprop="datePublished">2017-08-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mongo/">mongo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/08/mongo/">mongo 优化器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>mongodb优化方式很多跟MySQL类似如index、hint……。但是mongodb的查询优化器与MySQL稍有不同。例如一个索引能够精确匹配一个查询，那么查询优化器就会使用设个索引，例如在A列上有一个索引idx_A,那么优化器会选择idx_A方案。否则可能会选择其他索引,那么其他索引中选哪呢。mongodb会在这些索引中找到最先返回100个结果的索引。这个查询计划会被缓存下来，直到数据发送较大的变动，查询优化器根据其他可选的查询计划重新评估然后选出最好的计划。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/08/mongo/" data-id="cj6vynzp80004m4q5zfr3uxj6" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongo/">mongo</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/githubhsb" target="_blank" title="Github"></a>
      
      
      
      
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OAuth2-0/">OAuth2.0</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongo/">mongo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统架构/">系统架构</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/系统架构/MySQL-容量规划/">MySQL 容量规划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统架构/MySQL主从拓扑结构/">MySQL主从拓扑结构</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">6</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/MySQL/" style="font-size: 19.5px;">MySQL</a> <a href="/tags/MySQL主主拓扑结构/" style="font-size: 14px;">MySQL主主拓扑结构</a> <a href="/tags/OAuth2-0/" style="font-size: 14px;">OAuth2.0</a> <a href="/tags/TCP-IP/" style="font-size: 22.25px;">TCP/IP</a> <a href="/tags/innodb/" style="font-size: 14px;">innodb</a> <a href="/tags/io/" style="font-size: 14px;">io</a> <a href="/tags/mongo/" style="font-size: 14px;">mongo</a> <a href="/tags/mysql/" style="font-size: 25px;">mysql</a> <a href="/tags/mysql分解关联/" style="font-size: 14px;">mysql分解关联</a> <a href="/tags/mysql重构查询方式/" style="font-size: 14px;">mysql重构查询方式</a> <a href="/tags/vrrp协议/" style="font-size: 14px;">vrrp协议</a> <a href="/tags/主从拓扑结构/" style="font-size: 14px;">主从拓扑结构</a> <a href="/tags/性能优化/" style="font-size: 16.75px;">性能优化</a> <a href="/tags/拓扑结构/" style="font-size: 14px;">拓扑结构</a> <a href="/tags/磁盘io/" style="font-size: 14px;">磁盘io</a> <a href="/tags/系统架构/" style="font-size: 19.5px;">系统架构</a> <a href="/tags/网络协议/" style="font-size: 25px;">网络协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/26/auth2.0/">OAuth2.0</a>
          </li>
        
          <li>
            <a href="/2017/08/24/MySQL_innodb_io/">MySQL innodb 索引原理</a>
          </li>
        
          <li>
            <a href="/2017/08/24/mysql_change_master/">MySQL切换主库</a>
          </li>
        
          <li>
            <a href="/2017/08/21/mysql_主主拓扑结构/">MySQL主主拓扑结构</a>
          </li>
        
          <li>
            <a href="/2017/08/16/network_vrrp/">vrrp协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 Snail&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;2331104980@qq.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>